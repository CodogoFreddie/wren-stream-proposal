# wren-stream-proposal

_A proposed reference API for wren streams, implemented in wren with no native optimisation._

__API explination below__


<!-- vim-markdown-toc GFM -->
* [Abstract](#abstract)
* [API:](#api)
   * [Not implemented](#not-implemented)
      * [Overflow](#overflow)

<!-- vim-markdown-toc -->

## Abstract

These streams would be used to unify the interface for file/stdin/stdout/network reading/writing.

The hope is that once an API for the `Stream` class is decided on, a partially native implementation can be made to improve performance.

A reference implementation can be found in `main.wren`, and an example usage can be found in `example.wren`.

Please have a play about, and try to find any issues/improvements

Opening __Issues__ and creating __Pull Requests__ is highly encouraged (and in fact the only reason this repo exists)

I hope that the code is clear, but if there is any confusion please open an issue, or message me on twitter [@FreddieRidell](https://twitter.com/freddieRidell)

## API:

Strings are written to the `Stream`'s `writeInterface`, this triggers the stream to call its `readFiber`, which can then iterate through a `Sequence` generated by the `Stream` to read the buffered data out. Once there is more more data to read, the `readFiber` `yield`s, and we wait until more data is buffered.

The `Stream` takes 3 flags as config:

+ `writeable`: can the `Stream` be written to in wren land
+ `readable`: can the `Stream` be read from in wren land
+ `readPartialChunk`: if false, the iterating over the stream will only produce chunks of _exactly_ `chunkSize` in length. The last call to `readFiber`, when the `Stream` is closed will produce chunks of any length.

### Not implemented

#### Overflow
Consider `var overflow = (stream.writeInterface = input)`.
If `input` will not fully fit in the stream buffer, the remainder is returned to `overflow` so the calling script can push the remaining data into the `Stream`.
